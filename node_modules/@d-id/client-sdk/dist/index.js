var se = /* @__PURE__ */ ((e) => (e.TRIAL = "trial", e.BASIC = "basic", e.ENTERPRISE = "enterprise", e.LITE = "lite", e.ADVANCED = "advanced", e))(se || {}), oe = /* @__PURE__ */ ((e) => (e.TRIAL = "deid-trial", e.PRO = "deid-pro", e.ENTERPRISE = "deid-enterprise", e.LITE = "deid-lite", e.ADVANCED = "deid-advanced", e.BUILD = "deid-api-build", e.LAUNCH = "deid-api-launch", e.SCALE = "deid-api-scale", e))(oe || {}), ce = /* @__PURE__ */ ((e) => (e.Created = "created", e.Started = "started", e.Done = "done", e.Error = "error", e.Rejected = "rejected", e.Ready = "ready", e))(ce || {}), de = /* @__PURE__ */ ((e) => (e.Unrated = "Unrated", e.Positive = "Positive", e.Negative = "Negative", e))(de || {}), I = /* @__PURE__ */ ((e) => (e.Functional = "Functional", e.TextOnly = "TextOnly", e.Maintenance = "Maintenance", e.Playground = "Playground", e.DirectPlayback = "DirectPlayback", e))(I || {}), B = /* @__PURE__ */ ((e) => (e.Embed = "embed", e.Query = "query", e.Partial = "partial", e.Answer = "answer", e.Complete = "done", e))(B || {}), le = /* @__PURE__ */ ((e) => (e.KnowledgeProcessing = "knowledge/processing", e.KnowledgeIndexing = "knowledge/indexing", e.KnowledgeFailed = "knowledge/error", e.KnowledgeDone = "knowledge/done", e))(le || {}), me = /* @__PURE__ */ ((e) => (e.Knowledge = "knowledge", e.Document = "document", e.Record = "record", e))(me || {}), ue = /* @__PURE__ */ ((e) => (e.Pdf = "pdf", e.Text = "text", e.Html = "html", e.Word = "word", e.Json = "json", e.Markdown = "markdown", e.Csv = "csv", e.Excel = "excel", e.Powerpoint = "powerpoint", e.Archive = "archive", e.Image = "image", e.Audio = "audio", e.Video = "video", e))(ue || {}), Q = /* @__PURE__ */ ((e) => (e.Clip = "clip", e.Talk = "talk", e))(Q || {});
const fe = (e) => {
  switch (e) {
    case "clip":
      return "clip";
    case "talk":
      return "talk";
    default:
      throw new Error(`Unknown video type: ${e}`);
  }
};
var j = /* @__PURE__ */ ((e) => (e.Start = "START", e.Stop = "STOP", e))(j || {}), W = /* @__PURE__ */ ((e) => (e.ChatAnswer = "chat/answer", e.ChatPartial = "chat/partial", e.StreamDone = "stream/done", e.StreamStarted = "stream/started", e.StreamFailed = "stream/error", e.StreamReady = "stream/ready", e.StreamCreated = "stream/created", e.StreamVideoCreated = "stream-video/started", e.StreamVideoDone = "stream-video/done", e.StreamVideoError = "stream-video/error", e.StreamVideoRejected = "stream-video/rejected", e))(W || {}), D = /* @__PURE__ */ ((e) => (e.New = "new", e.Fail = "fail", e.Connected = "connected", e.Connecting = "connecting", e.Closed = "closed", e.Completed = "completed", e.Disconnected = "disconnected", e))(D || {}), ge = /* @__PURE__ */ ((e) => (e.Amazon = "amazon", e.Microsoft = "microsoft", e.Afflorithmics = "afflorithmics", e.Elevenlabs = "elevenlabs", e))(ge || {}), he = /* @__PURE__ */ ((e) => (e.Public = "public", e.Premium = "premium", e.Private = "private", e))(he || {});
const H = "https://api.d-id.com", we = "wss://notifications.d-id.com", pe = "79f81a83a67430be2bc0fd61042b8faa";
async function G(e, t) {
  const s = {
    limit: (t == null ? void 0 : t.limit) ?? 3,
    delayMs: (t == null ? void 0 : t.delayMs) ?? 0,
    timeout: (t == null ? void 0 : t.timeout) ?? 3e4,
    timeoutErrorMessage: (t == null ? void 0 : t.timeoutErrorMessage) || "Timeout error",
    shouldRetryFn: (t == null ? void 0 : t.shouldRetryFn) ?? function() {
      return !0;
    }
  };
  let a;
  for (let n = 1; n <= s.limit; n++)
    try {
      if (!s.timeout)
        return await e();
      let i;
      const r = new Promise((l, h) => {
        e().then((d) => {
          clearTimeout(i), l(d);
        }).catch((d) => {
          clearTimeout(i), h(d);
        });
      }), o = new Promise((l, h) => {
        i = setTimeout(() => h(new Error(s.timeoutErrorMessage)), s.timeout);
      });
      return await Promise.race([r, o]);
    } catch (i) {
      if (a = i, !s.shouldRetryFn(i) || n >= s.limit)
        throw i;
      s.delayMs > 0 && await new Promise((r) => setTimeout(r, s.delayMs));
    }
  throw a;
}
const K = () => Math.random().toString(16).slice(2);
function ee() {
  let e = window.localStorage.getItem("did_external_key_id");
  return e || (e = Math.random().toString(16).slice(2), window.localStorage.setItem("did_external_key_id", e)), e;
}
let ye = K();
function te(e) {
  if (e.type === "bearer")
    return `Bearer ${e.token}`;
  if (e.type === "basic")
    return `Basic ${btoa(`${e.username}:${e.password}`)}`;
  if (e.type === "key")
    return `Client-Key ${e.clientKey}.${ee()}_${ye}`;
  throw new Error(`Unknown auth type: ${e}`);
}
const ve = (e) => G(e, {
  limit: 3,
  delayMs: 1e3,
  timeout: 0,
  shouldRetryFn: (t) => t.status === 429
});
function q(e, t = H, s) {
  const a = async (n, i) => {
    const {
      skipErrorHandler: r,
      ...o
    } = i || {}, m = await ve(() => fetch(t + (n != null && n.startsWith("/") ? n : `/${n}`), {
      ...o,
      headers: {
        ...o.headers,
        Authorization: te(e),
        "Content-Type": "application/json"
      }
    }));
    if (!m.ok) {
      let l = await m.text().catch(() => "Failed to fetch");
      throw s && !r && s(new Error(l), {
        url: n,
        options: o,
        headers: m.headers
      }), new Error(l);
    }
    return m.json();
  };
  return {
    get(n, i) {
      return a(n, {
        ...i,
        method: "GET"
      });
    },
    post(n, i, r) {
      return a(n, {
        ...r,
        body: JSON.stringify(i),
        method: "POST"
      });
    },
    delete(n, i, r) {
      return a(n, {
        ...r,
        body: JSON.stringify(i),
        method: "DELETE"
      });
    },
    patch(n, i, r) {
      return a(n, {
        ...r,
        body: JSON.stringify(i),
        method: "PATCH"
      });
    }
  };
}
function ne(e, t = H, s) {
  const a = q(e, `${t}/agents`, s);
  return {
    create(n, i) {
      return a.post("/", n, i);
    },
    getAgents(n, i) {
      return a.get(`/${n ? `?tag=${n}` : ""}`, i).then((r) => r ?? []);
    },
    getById(n, i) {
      return a.get(`/${n}`, i);
    },
    delete(n, i) {
      return a.delete(`/${n}`, void 0, i);
    },
    update(n, i, r) {
      return a.patch(`/${n}`, i, r);
    },
    newChat(n, i, r) {
      return a.post(`/${n}/chat`, i, r);
    },
    chat(n, i, r, o) {
      return a.post(`/${n}/chat/${i}`, r, o);
    },
    createRating(n, i, r, o) {
      return a.post(`/${n}/chat/${i}/ratings`, r, o);
    },
    updateRating(n, i, r, o, m) {
      return a.patch(`/${n}/chat/${i}/ratings/${r}`, o, m);
    },
    deleteRating(n, i, r, o) {
      return a.delete(`/${n}/chat/${i}/ratings/${r}`, o);
    },
    getSTTToken(n, i) {
      return a.get(`/${n}/stt-token`, i);
    }
  };
}
const ke = (e) => new Promise((t) => setTimeout(t, e));
function Ce(e) {
  return new Promise((t, s) => {
    const {
      callbacks: a,
      host: n,
      auth: i
    } = e, {
      onMessage: r = null,
      onOpen: o = null,
      onClose: m = null,
      onError: l = null
    } = a || {}, h = new WebSocket(`${n}?authorization=${te(i)}`);
    h.onmessage = r, h.onclose = m, h.onerror = (d) => {
      console.error(d), l == null || l("Websocket failed to connect", d), s(d);
    }, h.onopen = (d) => {
      o == null || o(d), t(h);
    };
  });
}
async function Re(e) {
  const {
    retries: t = 1
  } = e;
  let s = null;
  for (let a = 0; (s == null ? void 0 : s.readyState) !== WebSocket.OPEN; a++)
    try {
      s = await Ce(e);
    } catch (n) {
      if (a === t)
        throw n;
      await ke(a * 500);
    }
  return s;
}
async function De(e, t, s) {
  const a = s != null && s.onMessage ? [s.onMessage] : [], n = await Re({
    auth: e,
    host: t,
    callbacks: {
      onError: s == null ? void 0 : s.onError,
      onMessage: (i) => {
        const r = JSON.parse(i.data);
        a.forEach((o) => o(r.event, r));
      }
    }
  });
  return {
    socket: n,
    disconnect: () => n.close(),
    subscribeToEvents: (i) => a.push(i)
  };
}
const Se = "X-Playground-Chat";
function _e(e, t, s, a) {
  const n = q(e, `${t}/agents/${s}`, a);
  return {
    createStream(i) {
      return n.post("/streams", {
        output_resolution: i.output_resolution,
        compatibility_mode: i.compatibility_mode,
        stream_warmup: i.stream_warmup,
        session_timeout: i.session_timeout,
        stream_greeting: i.stream_greeting
      });
    },
    startConnection(i, r, o) {
      return n.post(`/streams/${i}/sdp`, {
        session_id: o,
        answer: r
      });
    },
    addIceCandidate(i, r, o) {
      return n.post(`/streams/${i}/ice`, {
        session_id: o,
        ...r
      });
    },
    sendStreamRequest(i, r, o) {
      return n.post(`/streams/${i}`, {
        session_id: r,
        ...o
      });
    },
    close(i, r) {
      return n.delete(`/streams/${i}`, {
        session_id: r
      });
    }
  };
}
function Me(e, t, s, a) {
  const n = q(e, `${t}/agents/${s}`, a);
  return {
    createStream(i, r) {
      return n.post("/streams", {
        driver_url: i.driver_url,
        face: i.face,
        config: i.config,
        output_resolution: i.output_resolution,
        compatibility_mode: i.compatibility_mode,
        stream_warmup: i.stream_warmup,
        session_timeout: i.session_timeout,
        stream_greeting: i.stream_greeting
      }, r);
    },
    startConnection(i, r, o, m) {
      return n.post(`/streams/${i}/sdp`, {
        session_id: o,
        answer: r
      }, m);
    },
    addIceCandidate(i, r, o, m) {
      return n.post(`/streams/${i}/ice`, {
        session_id: o,
        ...r
      }, m);
    },
    sendStreamRequest(i, r, o, m) {
      return n.post(`/streams/${i}`, {
        session_id: r,
        ...o
      }, m);
    },
    close(i, r, o) {
      return n.delete(`/streams/${i}`, {
        session_id: r
      }, o);
    }
  };
}
function be(e, t, s) {
  const a = (t.timestamp - e.timestamp) / 1e3;
  return {
    duration: a,
    bytesReceived: t.bytesReceived - e.bytesReceived,
    bitrate: Math.round((t.bytesReceived - e.bytesReceived) * 8 / a),
    packetsReceived: t.packetsReceived - e.packetsReceived,
    packetsLost: t.packetsLost - e.packetsLost,
    framesDropped: t.framesDropped - e.framesDropped,
    framesDecoded: t.framesDecoded - e.framesDecoded,
    jitter: t.jitter,
    jitterBufferDelay: (t.jitterBufferDelay - e.jitterBufferDelay) / a,
    framesPerSecond: t.framesPerSecond,
    freezeCount: t.freezeCount - e.freezeCount,
    freezeDuration: t.freezeDuration - e.freezeDuration,
    lowFpsCount: s
  };
}
function Ee(e) {
  return e.filter((t) => t.freezeCount > 0 || t.framesPerSecond < 21 || t.framesDropped > 0 || t.packetsLost > 0).map((t) => {
    const {
      timestamp: s,
      ...a
    } = t, n = [];
    return t.freezeCount > 0 && n.push("freeze"), t.framesPerSecond < 21 && n.push("low fps"), t.framesDropped > 0 && n.push("frames dropped"), t.packetsLost > 0 && n.push("packet loss"), {
      ...a,
      causes: n
    };
  });
}
function Ie(e) {
  let t = "";
  for (const s of e.values())
    if (s && s.type === "codec" && s.mimeType.startsWith("video") && (t = s.mimeType.split("/")[1]), s && s.type === "inbound-rtp" && s.kind === "video")
      return {
        codec: t,
        timestamp: s.timestamp,
        bytesReceived: s.bytesReceived,
        packetsReceived: s.packetsReceived,
        packetsLost: s.packetsLost,
        framesDropped: s.framesDropped,
        framesDecoded: s.framesDecoded,
        jitter: s.jitter,
        jitterBufferDelay: s.jitterBufferDelay,
        frameWidth: s.frameWidth,
        frameHeight: s.frameHeight,
        framesPerSecond: s.framesPerSecond,
        freezeCount: s.freezeCount,
        freezeDuration: s.totalFreezesDuration
      };
  return {};
}
function Pe(e, t, s) {
  const a = e.map((r, o) => o === 0 ? s ? {
    timestamp: r.timestamp,
    duration: 0,
    bytesReceived: r.bytesReceived - s.bytesReceived,
    bitrate: (r.bytesReceived - s.bytesReceived) * 8 / (t / 1e3),
    packetsReceived: r.packetsReceived - s.packetsReceived,
    packetsLost: r.packetsLost - s.packetsLost,
    framesDropped: r.framesDropped - s.framesDropped,
    framesDecoded: r.framesDecoded - s.framesDecoded,
    jitter: r.jitter,
    jitterBufferDelay: r.jitterBufferDelay - s.jitterBufferDelay,
    framesPerSecond: r.framesPerSecond,
    freezeCount: r.freezeCount - s.freezeCount,
    freezeDuration: r.freezeDuration - s.freezeDuration
  } : {
    timestamp: r.timestamp,
    duration: 0,
    bytesReceived: r.bytesReceived,
    bitrate: r.bytesReceived * 8 / (t / 1e3),
    packetsReceived: r.packetsReceived,
    packetsLost: r.packetsLost,
    framesDropped: r.framesDropped,
    framesDecoded: r.framesDecoded,
    jitter: r.jitter,
    jitterBufferDelay: r.jitterBufferDelay,
    framesPerSecond: r.framesPerSecond,
    freezeCount: r.freezeCount,
    freezeDuration: r.freezeDuration
  } : {
    timestamp: r.timestamp,
    duration: t * o / 1e3,
    bytesReceived: r.bytesReceived - e[o - 1].bytesReceived,
    bitrate: (r.bytesReceived - e[o - 1].bytesReceived) * 8 / (t / 1e3),
    packetsReceived: r.packetsReceived - e[o - 1].packetsReceived,
    packetsLost: r.packetsLost - e[o - 1].packetsLost,
    framesDropped: r.framesDropped - e[o - 1].framesDropped,
    framesDecoded: r.framesDecoded - e[o - 1].framesDecoded,
    jitter: r.jitter,
    jitterBufferDelay: r.jitterBufferDelay - e[o - 1].jitterBufferDelay,
    framesPerSecond: r.framesPerSecond,
    freezeCount: r.freezeCount - e[o - 1].freezeCount,
    freezeDuration: r.freezeDuration - e[o - 1].freezeDuration
  }), n = Ee(a), i = n.reduce((r, o) => r + (o.causes.includes("low fps") ? 1 : 0), 0);
  return {
    webRTCStats: {
      anomalies: n,
      aggregateReport: be(e[0], e[e.length - 1], i)
    },
    codec: e[0].codec,
    resolution: `${e[0].frameWidth}x${e[0].frameHeight}`
  };
}
let re = !1;
const z = (e, t) => re && console.log(e, t), $e = (window.RTCPeerConnection || window.webkitRTCPeerConnection || window.mozRTCPeerConnection).bind(window);
function Y(e) {
  switch (e) {
    case "connected":
      return D.Connected;
    case "checking":
      return D.Connecting;
    case "failed":
      return D.Fail;
    case "new":
      return D.New;
    case "closed":
      return D.Closed;
    case "disconnected":
      return D.Disconnected;
    case "completed":
      return D.Completed;
    default:
      return D.New;
  }
}
function Ae() {
  let e = 0;
  return (t) => {
    for (const s of t.values())
      if (s && s.type === "inbound-rtp" && s.kind === "video") {
        const a = s.bytesReceived, n = a - e > 0;
        return e = a, n;
      }
    return !1;
  };
}
function Te(e, t, s = !1, a, n, i = !1) {
  const o = Math.max(Math.ceil(10), 1);
  let m = [], l, h = 0, d = !1;
  const k = s ? 1 : 0;
  let y = 0;
  const C = Ae();
  return setInterval(async () => {
    const w = await e.getStats(), f = C(w), M = Ie(w);
    if (f)
      h = 0, d || (t == null || t(j.Start), i && y >= k && !a() && n(), l = m[m.length - 1], m = [], y++, d = !0), m.push(M);
    else if (d && (h++, h >= o)) {
      const R = Pe(m, 100, l);
      t == null || t(j.Stop, R), !i && !a() && n(), d = !1;
    }
  }, 100);
}
async function ze(e, t, {
  debug: s = !1,
  callbacks: a,
  auth: n,
  baseURL: i = H,
  warmup: r
}) {
  re = s;
  const {
    startConnection: o,
    sendStreamRequest: m,
    close: l,
    createStream: h,
    addIceCandidate: d
  } = t.videoType === Q.Clip ? _e(n, i, e, a.onError) : Me(n, i, e, a.onError), {
    id: k,
    offer: y,
    ice_servers: C,
    session_id: w
  } = await h(t), f = new $e({
    iceServers: C
  }), M = f.createDataChannel("JanusDataChannel");
  if (!w)
    throw new Error("Could not create session_id");
  let R = !1;
  const c = () => R, g = () => {
    var u;
    R = !0, (u = a.onConnectionStateChange) == null || u.call(a, D.Connected);
  }, v = Te(f, a.onVideoStateChange, r, c, g, !!t.stream_greeting);
  f.onicecandidate = (u) => {
    var p;
    z("peerConnection.onicecandidate", u);
    try {
      u.candidate && u.candidate.sdpMid && u.candidate.sdpMLineIndex !== null ? d(k, {
        candidate: u.candidate.candidate,
        sdpMid: u.candidate.sdpMid,
        sdpMLineIndex: u.candidate.sdpMLineIndex
      }, w) : d(k, {
        candidate: null
      }, w);
    } catch (_) {
      (p = a.onError) == null || p.call(a, _, {
        streamId: k
      });
    }
  }, M.onopen = () => {
    !t.stream_warmup && !t.stream_greeting && g();
  }, f.oniceconnectionstatechange = () => {
    var p;
    z("peerConnection.oniceconnectionstatechange => " + f.iceConnectionState);
    const u = Y(f.iceConnectionState);
    u !== D.Connected && ((p = a.onConnectionStateChange) == null || p.call(a, u));
  }, f.ontrack = (u) => {
    var p;
    z("peerConnection.ontrack", u), (p = a.onSrcObjectReady) == null || p.call(a, u.streams[0]);
  }, await f.setRemoteDescription(y), z("set remote description OK");
  const S = await f.createAnswer();
  return z("create answer OK"), await f.setLocalDescription(S), z("set local description OK"), await o(k, S, w), z("start connection OK"), {
    /**
     * Method to send request to server to get clip or talk depend on you payload
     * @param payload
     */
    speak(u) {
      return m(k, w, u);
    },
    /**
     * Method to close RTC connection
     */
    async disconnect() {
      var u, p;
      if (k) {
        const _ = Y(f.iceConnectionState);
        if (f) {
          if (_ === D.New) {
            (u = a.onVideoStateChange) == null || u.call(a, j.Stop), clearInterval(v);
            return;
          }
          f.close(), f.oniceconnectionstatechange = null, f.onnegotiationneeded = null, f.onicecandidate = null, f.ontrack = null;
        }
        try {
          _ === D.Connected && await l(k, w).catch((b) => {
          });
        } catch (b) {
          z("Error on close stream connection", b);
        }
        (p = a.onVideoStateChange) == null || p.call(a, j.Stop), clearInterval(v);
      }
    },
    /**
     * Session identifier information, should be returned in the body of all streaming requests
     */
    sessionId: w,
    /**
     * Id of current RTC stream
     */
    streamId: k
  };
}
const J = (e) => e.type === "clip" && e.presenter_id.startsWith("v2_") ? "clip_v2" : e.type;
let U = {};
function Le(e) {
  var i, r, o, m, l, h;
  const t = window != null && window.hasOwnProperty("DID_AGENTS_API") ? "agents-ui" : "agents-sdk", s = e.agent.presenter, a = (i = e.agent.llm) == null ? void 0 : i.prompt_customization, n = {
    token: e.token || "testKey",
    distinct_id: e.distinctId || ee(),
    agentId: e.agent.id,
    agentType: J(s),
    owner_id: e.agent.owner_id ?? "",
    promptVersion: (r = e.agent.llm) == null ? void 0 : r.prompt_version,
    behavior: {
      role: a == null ? void 0 : a.role,
      personality: a == null ? void 0 : a.personality,
      instructions: (o = e.agent.llm) == null ? void 0 : o.instructions
    },
    temperature: (m = e.agent.llm) == null ? void 0 : m.temperature,
    knowledgeSource: a == null ? void 0 : a.knowledge_source,
    starterQuestionsCount: (h = (l = e.agent.knowledge) == null ? void 0 : l.starter_message) == null ? void 0 : h.length,
    topicsToAvoid: a == null ? void 0 : a.topics_to_avoid,
    maxResponseLength: a == null ? void 0 : a.max_response_length
  };
  return {
    ...n,
    additionalProperties: {},
    isEnabled: e.isEnabled ?? !0,
    getRandom: () => Math.random().toString(16).slice(2),
    enrich(d) {
      const k = {};
      if (d && typeof d != "object")
        throw new Error("properties must be a flat json object");
      for (let y in d)
        (typeof d[y] == "string" || typeof d[y] == "number") && (k[y] = d[y]);
      this.additionalProperties = {
        ...this.additionalProperties,
        ...k
      };
    },
    track(d, k) {
      if (!this.isEnabled)
        return Promise.resolve();
      const {
        audioPath: y,
        ...C
      } = k || {}, w = {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: new URLSearchParams({
          data: JSON.stringify([{
            event: d,
            properties: {
              ...this.additionalProperties,
              ...C,
              ...n,
              source: t,
              time: Date.now(),
              $insert_id: this.getRandom(),
              origin: window.location.href,
              "Screen Height": window.screen.height || window.innerWidth,
              "Screen Width": window.screen.width || window.innerHeight,
              "User Agent": navigator.userAgent
            }
          }])
        })
      };
      return fetch("https://api-js.mixpanel.com/track/?verbose=1&ip=1", w).then((f) => f.json()).catch((f) => console.error(f));
    },
    linkTrack(d, k, y, C) {
      U[d] || (U[d] = {
        events: {},
        resolvedDependencies: []
      }), C.includes(y) || C.push(y);
      const w = U[d];
      if (w.events[y] = {
        props: k
      }, w.resolvedDependencies.push(y), C.every((M) => w.resolvedDependencies.includes(M))) {
        const M = C.reduce((R, c) => w.events[c] ? {
          ...R,
          ...w.events[c].props
        } : R, {});
        this.track(d, M), w.resolvedDependencies = w.resolvedDependencies.filter((R) => !C.includes(R)), C.forEach((R) => {
          delete w.events[R];
        });
      }
    }
  };
}
function je(e) {
  var n, i, r, o;
  const t = () => /Mobi|Android/i.test(navigator.userAgent) ? "Mobile" : "Desktop", s = () => {
    const m = navigator.platform;
    return m.toLowerCase().includes("win") ? "Windows" : m.toLowerCase().includes("mac") ? "Mac OS X" : m.toLowerCase().includes("linux") ? "Linux" : "Unknown";
  }, a = e.presenter;
  return {
    $os: `${s()}`,
    isMobile: `${t() == "Mobile"}`,
    browser: navigator.userAgent,
    origin: window.location.origin,
    agentType: J(a),
    agentVoice: {
      voiceId: (i = (n = e.presenter) == null ? void 0 : n.voice) == null ? void 0 : i.voice_id,
      provider: (o = (r = e.presenter) == null ? void 0 : r.voice) == null ? void 0 : o.type
    }
  };
}
function xe(e, t, s) {
  var l, h;
  const {
    event: a,
    ...n
  } = e, {
    template: i
  } = (t == null ? void 0 : t.llm) || {}, {
    language: r
  } = ((l = t == null ? void 0 : t.presenter) == null ? void 0 : l.voice) || {}, {
    stitch: o
  } = (t == null ? void 0 : t.presenter) || {};
  return {
    ...n,
    llm: {
      ...n.llm,
      template: i
    },
    script: {
      ...n.script,
      provider: {
        ...(h = n == null ? void 0 : n.script) == null ? void 0 : h.provider,
        language: r
      }
    },
    stitch: o,
    ...s
  };
}
class Ne extends Error {
  constructor({
    kind: t,
    description: s
  }) {
    const a = JSON.stringify({
      kind: t,
      description: s
    });
    super(a);
  }
}
let L = 0;
const Be = 45 * 1e3;
function Fe(e, t, s) {
  var a, n, i, r, o;
  return {
    videoType: fe(e.presenter.type),
    output_resolution: (a = t == null ? void 0 : t.streamOptions) == null ? void 0 : a.outputResolution,
    session_timeout: (n = t == null ? void 0 : t.streamOptions) == null ? void 0 : n.sessionTimeout,
    stream_warmup: (i = t == null ? void 0 : t.streamOptions) == null ? void 0 : i.streamWarmup,
    compatibility_mode: (r = t == null ? void 0 : t.streamOptions) == null ? void 0 : r.compatibilityMode,
    stream_greeting: J(e.presenter) !== "clip" && ((o = t == null ? void 0 : t.streamOptions) != null && o.streamGreeting) ? s : void 0
  };
}
function ae(e) {
  return e === I.Playground ? {
    headers: {
      [Se]: "true"
    }
  } : {};
}
async function ie(e, t, s, a, n) {
  try {
    const i = await t.newChat(e, {
      persist: n ?? !1
    }, ae(a));
    return s.track("agent-chat", {
      event: "created",
      chat_id: i.id,
      agent_id: e,
      mode: a
    }), i;
  } catch (i) {
    let r;
    try {
      r = JSON.parse(i.message);
    } catch (o) {
      console.error("Error parsing the error message:", o);
    }
    throw (r == null ? void 0 : r.kind) === "InsufficientCreditsError" ? new Error("InsufficientCreditsError") : new Error("Cannot create new chat");
  }
}
function He(e, t, s, a, n, i) {
  return new Promise(async (r, o) => {
    var d, k, y, C, w;
    L = 0;
    const m = String(t.mode);
    if (!n && t.mode !== I.DirectPlayback)
      try {
        n = await ie(e.id, s, a, t.mode, t.persistentChat);
      } catch (f) {
        return o(f);
      }
    const l = (n == null ? void 0 : n.chat_mode) || m;
    if (l !== m && (t.mode = l, (k = (d = t.callbacks).onModeChange) == null || k.call(d, l), l === I.TextOnly && ((C = (y = t.callbacks) == null ? void 0 : y.onError) == null || C.call(y, new Ne({
      kind: "ChatModeDowngraded",
      description: `Chat mode changed from ${m} to ${l} when creating the chat`
    }), {}))), l === I.TextOnly)
      return r({
        chat: n
      });
    const h = await ze(e.id, Fe(e, t, i), {
      ...t,
      analytics: a,
      warmup: (w = t.streamOptions) == null ? void 0 : w.streamWarmup,
      callbacks: {
        ...t.callbacks,
        onConnectionStateChange: async (f) => {
          var M, R, c, g;
          f === D.Connected ? h ? ((R = (M = t.callbacks).onConnectionStateChange) == null || R.call(M, f), r({
            chat: n,
            streamingManager: h
          })) : n && o(new Error("Something went wrong while initializing the manager")) : (g = (c = t.callbacks).onConnectionStateChange) == null || g.call(c, f);
        },
        onVideoStateChange(f, M) {
          var R, c;
          (c = (R = t.callbacks).onVideoStateChange) == null || c.call(R, f), L > 0 && (f === j.Start ? a.linkTrack("agent-video", {
            event: "start",
            latency: Date.now() - L
          }, "start", [W.StreamVideoCreated]) : f === j.Stop && a.linkTrack("agent-video", {
            event: "stop",
            is_greenscreen: e.presenter.type === "clip" && e.presenter.is_greenscreen,
            background: e.presenter.type === "clip" && e.presenter.background,
            ...M
          }, "done", [W.StreamVideoDone]));
        }
      }
    }).catch(o);
  });
}
function Ve(e) {
  var s;
  const t = (s = e.greetings) == null ? void 0 : s.filter((a) => a.length > 0);
  if (t && t.length > 0) {
    const a = Math.floor(Math.random() * t.length);
    return t[a];
  } else
    return `Hi! I'm ${e.preview_name || "My Agent"}. How can I help you?`;
}
function Z(e, t) {
  return t && t.length > 0 ? t : [{
    content: e,
    id: K(),
    role: "assistant",
    created_at: (/* @__PURE__ */ new Date()).toISOString()
  }];
}
function We(e) {
  if (e.answer !== void 0)
    return e.answer;
  let t = 0, s = "";
  for (; t in e; )
    s += e[t], t++;
  return s;
}
function Ke(e, t, s, a, n) {
  if (!(e === B.Partial || e === B.Answer))
    return;
  const i = a.messages[a.messages.length - 1];
  if ((i == null ? void 0 : i.role) !== "assistant")
    return;
  const {
    content: r,
    sequence: o
  } = t;
  e === B.Partial ? s[o] = r : s.answer = r;
  const m = We(s);
  (i.content !== m || e === B.Answer) && (i.content = m, n == null || n([...a.messages], e));
}
async function Ue(e, t) {
  var f, M, R;
  let s = {}, a = !0;
  const n = {
    messages: [],
    chatMode: t.mode || I.Functional
  }, i = t.baseURL || H, r = t.wsURL || we, o = t.mixpanelKey || pe, m = ne(t.auth, i, t.callbacks.onError), l = await m.getById(e), h = Ve(l);
  n.messages = Z(h, t.initialMessages), (M = (f = t.callbacks).onNewMessage) == null || M.call(f, [...n.messages], "answer");
  const d = Le({
    token: o,
    agent: l,
    isEnabled: t.enableAnalitics,
    distinctId: t.distinctId
  });
  d.track("agent-sdk", {
    event: "loaded",
    ...je(l)
  });
  const k = {
    onMessage: (c, g) => {
      var v, S;
      if ("content" in g)
        Ke(c, g, s, n, t.callbacks.onNewMessage), c === B.Answer && d.track("agent-message-received", {
          messages: n.messages.length,
          mode: n.chatMode
        });
      else {
        const u = W, p = [u.StreamVideoDone, u.StreamVideoError, u.StreamVideoRejected], _ = [u.StreamFailed, u.StreamVideoError, u.StreamVideoRejected], b = xe(g, l, {
          mode: n.chatMode
        });
        if (c = c, c === u.StreamVideoCreated)
          d.linkTrack("agent-video", b, u.StreamVideoCreated, ["start"]);
        else if (p.includes(c)) {
          const E = c.split("/")[1];
          _.includes(c) ? d.track("agent-video", {
            ...b,
            event: E
          }) : d.linkTrack("agent-video", {
            ...b,
            event: E
          }, c, ["done"]);
        }
        _.includes(c) && ((S = (v = t.callbacks).onError) == null || S.call(v, new Error(`Stream failed with event ${c}`), {
          data: g
        })), g.event === u.StreamDone && C();
      }
    }
  };
  async function y(c) {
    var _, b, E, A, F, T, P;
    (b = (_ = t.callbacks).onConnectionStateChange) == null || b.call(_, D.Connecting), L = 0, c && !a && (delete n.chat, n.messages = Z(h), (A = (E = t.callbacks).onNewMessage) == null || A.call(E, [...n.messages], "answer"));
    const g = t.mode === I.DirectPlayback ? Promise.resolve(void 0) : De(t.auth, r, k), v = G(() => He(l, t, m, d, n.chat, c ? h : void 0), {
      limit: 3,
      timeout: Be,
      timeoutErrorMessage: "Timeout initializing the stream",
      // Retry on all errors except for connection errors and rate limit errors, these are already handled in client level.
      shouldRetryFn: ($) => ($ == null ? void 0 : $.message) !== "Could not connect" && $.status !== 429,
      delayMs: 1e3
    }).catch(($) => {
      var x, N;
      throw w(I.Maintenance), (N = (x = t.callbacks).onConnectionStateChange) == null || N.call(x, D.Fail), $;
    }), [S, {
      streamingManager: u,
      chat: p
    }] = await Promise.all([g, v]);
    p && p.id !== ((F = n.chat) == null ? void 0 : F.id) && ((P = (T = t.callbacks).onNewChat) == null || P.call(T, p.id)), n.streamingManager = u, n.socketManager = S, n.chat = p, a = !1, w((p == null ? void 0 : p.chat_mode) ?? t.mode ?? I.Functional);
  }
  async function C() {
    var c, g, v, S;
    (c = n.socketManager) == null || c.disconnect(), await ((g = n.streamingManager) == null ? void 0 : g.disconnect()), delete n.streamingManager, delete n.socketManager, (S = (v = t.callbacks).onConnectionStateChange) == null || S.call(v, D.Disconnected);
  }
  async function w(c) {
    var g, v;
    c !== n.chatMode && (d.track("agent-mode-change", {
      mode: c
    }), n.chatMode = c, n.chatMode !== I.Functional && await C(), (v = (g = t.callbacks).onModeChange) == null || v.call(g, c));
  }
  return {
    agent: l,
    starterMessages: ((R = l.knowledge) == null ? void 0 : R.starter_message) || [],
    getSTTToken: () => m.getSTTToken(l.id),
    changeMode: w,
    enrichAnalytics: d.enrich,
    async connect() {
      var c;
      await y(!0), d.track("agent-chat", {
        event: "connect",
        chatId: (c = n.chat) == null ? void 0 : c.id,
        agentId: l.id,
        mode: n.chatMode
      });
    },
    async reconnect() {
      var c;
      await C(), await y(!1), d.track("agent-chat", {
        event: "reconnect",
        chatId: (c = n.chat) == null ? void 0 : c.id,
        agentId: l.id,
        mode: n.chatMode
      });
    },
    async disconnect() {
      var c;
      await C(), d.track("agent-chat", {
        event: "disconnect",
        chatId: (c = n.chat) == null ? void 0 : c.id,
        agentId: l.id,
        mode: n.chatMode
      });
    },
    async chat(c) {
      var v, S, u, p, _, b;
      const g = K();
      s = {};
      try {
        if (L = Date.now(), t.mode === I.DirectPlayback)
          throw new Error("Direct playback is enabled, chat is disabled");
        if (c.length >= 800)
          throw new Error("Message cannot be more than 800 characters");
        if (c.length === 0)
          throw new Error("Message cannot be empty");
        if (n.chatMode === I.Maintenance)
          throw new Error("Chat is in maintenance mode");
        if (![I.TextOnly, I.Playground].includes(n.chatMode))
          if (n.streamingManager) {
            if (!n.chat)
              throw new Error("Chat is not initialized");
          } else
            throw new Error("Streaming manager is not initialized");
        n.messages.push({
          id: K(),
          role: "user",
          content: c,
          created_at: new Date(L).toISOString()
        }), (S = (v = t.callbacks).onNewMessage) == null || S.call(v, [...n.messages], "user"), n.chat || (n.chat = await ie(l.id, m, d, n.chatMode, t.persistentChat), (p = (u = t.callbacks).onNewChat) == null || p.call(u, n.chat.id));
        const E = {
          id: g,
          role: "assistant",
          content: "",
          created_at: (/* @__PURE__ */ new Date()).toISOString(),
          matches: []
        }, A = [...n.messages];
        n.messages.push(E);
        const F = (P) => {
          var $, x;
          return m.chat(l.id, P, {
            sessionId: ($ = n.streamingManager) == null ? void 0 : $.sessionId,
            streamId: (x = n.streamingManager) == null ? void 0 : x.streamId,
            chatMode: n.chatMode,
            messages: A.map(({
              matches: N,
              ...V
            }) => V)
          }, {
            ...ae(n.chatMode),
            skipErrorHandler: !0
          });
        }, T = await F(n.chat.id).catch(async (P) => {
          var N, V, O, X;
          const $ = (N = P == null ? void 0 : P.message) == null ? void 0 : N.includes("missing or invalid session_id");
          if (!((V = P == null ? void 0 : P.message) == null ? void 0 : V.includes("Stream Error")) && !$)
            throw (X = (O = t.callbacks).onError) == null || X.call(O, P, {}), P;
          return await C(), await y(!1), F(n.chat.id);
        });
        return d.track("agent-message-send", {
          event: "success",
          mode: n.chatMode,
          messages: n.messages.length + 1
        }), E.context = T.context, E.matches = T.matches, T.result && (E.content = T.result, d.track("agent-message-received", {
          latency: Date.now() - L,
          mode: n.chatMode,
          messages: n.messages.length
        }), (b = (_ = t.callbacks).onNewMessage) == null || b.call(_, [...n.messages], "answer")), T;
      } catch (E) {
        throw n.messages[n.messages.length - 1].id === g && n.messages.pop(), d.track("agent-message-send", {
          event: "error",
          mode: n.chatMode,
          messages: n.messages.length
        }), E;
      }
    },
    rate(c, g, v) {
      var p, _, b, E;
      const S = n.messages.find((A) => A.id === c);
      if (n.chat) {
        if (!S)
          throw new Error("Message not found");
      } else
        throw new Error("Chat is not initialized");
      const u = ((p = S.matches) == null ? void 0 : p.map((A) => [A.document_id, A.id])) ?? [];
      return d.track("agent-rate", {
        event: v ? "update" : "create",
        thumb: g === 1 ? "up" : "down",
        knowledge_id: ((_ = l.knowledge) == null ? void 0 : _.id) ?? "",
        mode: n.chatMode,
        matches: u,
        score: g
      }), v ? m.updateRating(l.id, n.chat.id, v, {
        knowledge_id: ((b = l.knowledge) == null ? void 0 : b.id) ?? "",
        message_id: c,
        matches: u,
        score: g
      }) : m.createRating(l.id, n.chat.id, {
        knowledge_id: ((E = l.knowledge) == null ? void 0 : E.id) ?? "",
        message_id: c,
        matches: u,
        score: g
      });
    },
    deleteRate(c) {
      var g;
      if (!n.chat)
        throw new Error("Chat is not initialized");
      return d.track("agent-rate-delete", {
        type: "text",
        chat_id: (g = n.chat) == null ? void 0 : g.id,
        id: c,
        mode: n.chatMode
      }), m.deleteRating(l.id, n.chat.id, c);
    },
    speak(c) {
      if (!n.streamingManager)
        throw new Error("Please connect to the agent first");
      L = Date.now();
      function g() {
        if (typeof c == "string") {
          if (!l.presenter.voice)
            throw new Error("Presenter voice is not initialized");
          return {
            type: "text",
            provider: l.presenter.voice,
            input: c,
            ssml: !1
          };
        }
        if (c.type === "text" && !c.provider) {
          if (!l.presenter.voice)
            throw new Error("Presenter voice is not initialized");
          return {
            type: "text",
            provider: l.presenter.voice,
            input: c.input,
            ssml: c.ssml
          };
        }
        return c;
      }
      const v = g();
      return d.track("agent-speak", v), n.streamingManager.speak({
        script: v
      });
    }
  };
}
function qe(e, t, s) {
  const {
    getById: a
  } = ne(t, s || H);
  return a(e);
}
export {
  ce as AgentStatus,
  I as ChatMode,
  B as ChatProgress,
  D as ConnectionState,
  ue as DocumentType,
  me as KnowledgeType,
  oe as PlanGroup,
  ge as Providers,
  de as RateState,
  W as StreamEvents,
  j as StreamingState,
  le as Subject,
  se as UserPlan,
  Q as VideoType,
  he as VoiceAccess,
  Ue as createAgentManager,
  qe as getAgent,
  fe as mapVideoType
};
